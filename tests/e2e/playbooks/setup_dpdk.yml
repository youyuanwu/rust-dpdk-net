---
# Setup DPDK on VMs
- name: Setup DPDK Environment
  hosts: vm1
  become: true
  
  vars:
    # playbook_dir is tests/e2e/playbooks, go up 3 levels to project root
    project_root: "{{ playbook_dir }}/../../../"
    dpdk_deb_local: "{{ project_root }}/build/dpdk-net_22.11.11_amd64.deb"
    dpdk_deb_remote: /tmp/dpdk-net_22.11.11_amd64.deb
    dpdk_version: "22.11.11"
    dpdk_pkg_name: "dpdk-net"

  tasks:
    - name: Get local deb checksum
      ansible.builtin.stat:
        path: "{{ dpdk_deb_local }}"
        checksum_algorithm: md5
      register: local_deb
      delegate_to: localhost
      become: false

    - name: Get remote deb checksum
      ansible.builtin.stat:
        path: "{{ dpdk_deb_remote }}"
        checksum_algorithm: md5
      register: remote_deb

    - name: Determine if deb needs update
      ansible.builtin.set_fact:
        deb_needs_update: "{{ not remote_deb.stat.exists or (remote_deb.stat.checksum != local_deb.stat.checksum) }}"

    - name: Copy DPDK deb to VM (if missing or hash mismatch)
      ansible.builtin.copy:
        src: "{{ dpdk_deb_local }}"
        dest: "{{ dpdk_deb_remote }}"
        mode: '0644'
      when: deb_needs_update

    - name: Install DPDK dependencies
      ansible.builtin.apt:
        name:
          - libnuma1
          - libelf1t64
          - zlib1g
          - libzstd1
          - libatomic1
          - rdma-core
          - libibverbs1
          - libmlx5-1
          - librdmacm1
        state: present
        update_cache: true

    - name: Remove old DPDK packages (if deb changed)
      ansible.builtin.apt:
        name:
          - dpdk
          - dpdk-net
        state: absent
        purge: true
      when: deb_needs_update
      ignore_errors: true

    - name: Install DPDK from deb
      ansible.builtin.apt:
        deb: "{{ dpdk_deb_remote }}"
        state: present
      when: deb_needs_update

    - name: Update shared library cache
      ansible.builtin.command: ldconfig
      when: deb_needs_update

    - name: Verify DPDK installation
      ansible.builtin.shell: |
        echo "=== DPDK Package Info ==="
        dpkg -l {{ dpdk_pkg_name }}
        echo ""
        echo "=== DPDK Libraries ==="
        ls -la /usr/local/lib/x86_64-linux-gnu/librte*.so.* 2>/dev/null | head -5 || echo "Libraries in different location"
        echo ""
        echo "=== DPDK Binaries ==="
        ls -la /usr/local/bin/dpdk-* 2>/dev/null | head -5 || echo "No binaries found in /usr/local/bin"
      register: dpdk_info
      changed_when: false

    - name: Display DPDK installation info
      ansible.builtin.debug:
        msg: "{{ dpdk_info.stdout_lines }}"

    - name: Configure hugepages (2MB) - skip for local VMs (configured via Terraform)
      ansible.builtin.shell: |
        echo 1024 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
        mkdir -p /mnt/huge
        mount -t hugetlbfs nodev /mnt/huge || true
        echo "Hugepages configured:"
        cat /proc/meminfo | grep Huge
      register: hugepages_result
      when: not (is_local | default(false))

    - name: Check existing hugepages (local VMs)
      ansible.builtin.shell: cat /proc/meminfo | grep Huge
      register: hugepages_result
      changed_when: false
      when: is_local | default(false)

    - name: Display hugepages info
      ansible.builtin.debug:
        msg: "{{ hugepages_result.stdout_lines }}"

    # ============================================================================
    # VFIO-PCI binding for local VMs (QEMU/KVM virtio devices)
    # Required because DPDK virtio PMD needs userspace driver access
    # Uses noiommu mode since VMs don't have hardware IOMMU
    # ============================================================================

    - name: Load vfio modules (local VMs)
      community.general.modprobe:
        name: "{{ item }}"
        state: present
      loop:
        - vfio
        - vfio_pci
      when: is_local | default(false)

    - name: Enable unsafe noiommu mode for vfio (required without hardware IOMMU)
      ansible.builtin.shell: |
        echo 1 > /sys/module/vfio/parameters/enable_unsafe_noiommu_mode
      changed_when: false
      when: is_local | default(false)

    # Try to get PCI address from interface (works before binding to vfio-pci)
    - name: Check if DPDK interface still exists
      ansible.builtin.stat:
        path: "/sys/class/net/{{ dpdk_interface }}/device"
      register: dpdk_interface_exists
      when: is_local | default(false)

    - name: Get DPDK interface PCI address from interface
      ansible.builtin.shell: |
        readlink -f /sys/class/net/{{ dpdk_interface }}/device | xargs dirname | xargs basename
      register: dpdk_pci_from_interface
      changed_when: false
      when: 
        - is_local | default(false)
        - dpdk_interface_exists.stat.exists | default(false)

    # Fallback: find virtio-net device already bound to vfio-pci (second NIC = second virtio)
    # On our VMs: enp0s3 (0000:00:03.0) = management, enp0s4 (0000:00:04.0) = DPDK
    - name: Find virtio PCI device bound to vfio-pci (fallback for subsequent runs)
      ansible.builtin.shell: |
        # Look for the DPDK NIC PCI address (0000:00:04.0 for second virtio NIC)
        ls /sys/bus/pci/drivers/vfio-pci/ 2>/dev/null | grep -E '^[0-9a-f]{4}:[0-9a-f]{2}:[0-9a-f]{2}\.[0-9]$' | grep -v '0000:00:03' | head -1
      register: dpdk_pci_from_vfio
      changed_when: false
      when: 
        - is_local | default(false)
        - not (dpdk_interface_exists.stat.exists | default(false))

    - name: Set DPDK PCI address fact
      ansible.builtin.set_fact:
        dpdk_pci_addr: "{{ dpdk_pci_from_interface.stdout | default(dpdk_pci_from_vfio.stdout | default('')) }}"
      when: is_local | default(false)

    - name: Display detected DPDK PCI address
      ansible.builtin.debug:
        msg: "DPDK interface {{ dpdk_interface }} PCI address: {{ dpdk_pci_addr }}"
      when: 
        - is_local | default(false)
        - dpdk_pci_addr != ""

    - name: Check if DPDK device is bound to vfio-pci
      ansible.builtin.stat:
        path: "/sys/bus/pci/drivers/vfio-pci/{{ dpdk_pci_addr }}"
      register: dpdk_vfio_bound
      when: 
        - is_local | default(false)
        - dpdk_pci_addr != ""

    - name: Unbind DPDK device from kernel driver
      ansible.builtin.shell: |
        PCI_ADDR="{{ dpdk_pci_addr }}"
        # Only unbind if currently bound to a driver
        if [ -L "/sys/bus/pci/devices/$PCI_ADDR/driver" ]; then
          CURRENT_DRIVER=$(basename $(readlink /sys/bus/pci/devices/$PCI_ADDR/driver))
          echo "Currently bound to: $CURRENT_DRIVER"
          echo "$PCI_ADDR" > /sys/bus/pci/devices/$PCI_ADDR/driver/unbind
          echo "Unbound from $CURRENT_DRIVER"
        fi
      when: 
        - is_local | default(false)
        - dpdk_pci_addr != ""
        - not (dpdk_vfio_bound.stat.exists | default(false))
      register: dpdk_unbind_result
      changed_when: "'Unbound' in dpdk_unbind_result.stdout"

    - name: Bind DPDK device to vfio-pci
      ansible.builtin.shell: |
        PCI_ADDR="{{ dpdk_pci_addr }}"
        echo "vfio-pci" > /sys/bus/pci/devices/$PCI_ADDR/driver_override
        echo "$PCI_ADDR" > /sys/bus/pci/drivers/vfio-pci/bind
        echo "Bound $PCI_ADDR to vfio-pci"
      when: 
        - is_local | default(false)
        - dpdk_pci_addr != ""
        - not (dpdk_vfio_bound.stat.exists | default(false))
      register: dpdk_bind_result

    - name: Verify DPDK device bound to vfio-pci
      ansible.builtin.stat:
        path: "/sys/bus/pci/drivers/vfio-pci/{{ dpdk_pci_addr }}"
      register: dpdk_vfio_verify
      failed_when: not dpdk_vfio_verify.stat.exists
      when: 
        - is_local | default(false)
        - dpdk_pci_addr != ""

    - name: Display vfio-pci binding status
      ansible.builtin.debug:
        msg: "DPDK device {{ dpdk_pci_addr }} successfully bound to vfio-pci"
      when: 
        - is_local | default(false)
        - dpdk_pci_addr != ""
