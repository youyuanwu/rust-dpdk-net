// Bindings generated by `windows-bindgen` 0.66.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]

windows_link::link!("dpdk_dummy" "C" fn rte_dev_bus(dev : *const core::ffi::c_void) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_bus_info(dev : *const core::ffi::c_void) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_devargs(dev : *const core::ffi::c_void) -> *mut rte_devargs);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_dma_map(dev : *mut core::ffi::c_void, addr : *mut core::ffi::c_void, iova : u64, len : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_dma_unmap(dev : *mut core::ffi::c_void, addr : *mut core::ffi::c_void, iova : u64, len : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_driver(dev : *const core::ffi::c_void) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_event_callback_process(device_name : *const i8, event : rte_dev_event_type));
windows_link::link!("dpdk_dummy" "C" fn rte_dev_event_callback_register(device_name : *const i8, cb_fn : rte_dev_event_cb_fn, cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_event_callback_unregister(device_name : *const i8, cb_fn : rte_dev_event_cb_fn, cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_event_monitor_start() -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_event_monitor_stop() -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_hotplug_handle_disable() -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_hotplug_handle_enable() -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_is_probed(dev : *const core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_iterator_init(it : *mut rte_dev_iterator, str : *const i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_iterator_next(it : *mut rte_dev_iterator) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_name(dev : *const core::ffi::c_void) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_numa_node(dev : *const core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_probe(devargs : *const i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_dev_remove(dev : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_add(devtype : rte_devtype, devargs_str : *const i8) -> i32);
#[cfg(feature = "lcore")]
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_dump(f : *mut _IO_FILE));
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_insert(da : *mut *mut rte_devargs) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_next(busname : *const i8, start : *const rte_devargs) -> *mut rte_devargs);
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_parse(da : *mut rte_devargs, dev : *const i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_remove(devargs : *mut rte_devargs) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_reset(da : *mut rte_devargs));
windows_link::link!("dpdk_dummy" "C" fn rte_devargs_type_count(devtype : rte_devtype) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_driver_name(driver : *const core::ffi::c_void) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eal_hotplug_add(busname : *const i8, devname : *const i8, drvargs : *const i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eal_hotplug_remove(busname : *const i8, devname : *const i8) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_add_first_rx_callback(port_id : u16, queue_id : u16, r#fn : rte_rx_callback_fn, user_param : *mut core::ffi::c_void) -> *mut core::ffi::c_void);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_add_rx_callback(port_id : u16, queue_id : u16, r#fn : rte_rx_callback_fn, user_param : *mut core::ffi::c_void) -> *mut core::ffi::c_void);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_add_tx_callback(port_id : u16, queue_id : u16, r#fn : rte_tx_callback_fn, user_param : *mut core::ffi::c_void) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_allmulticast_disable(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_allmulticast_enable(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_allmulticast_get(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_buffer_split_get_supported_hdr_ptypes(port_id : u16, ptypes : *mut u32, num : i32) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_call_rx_callbacks(port_id : u16, queue_id : u16, rx_pkts : *mut *mut super::mbuf:: rte_mbuf, nb_rx : u16, nb_pkts : u16, opaque : *mut core::ffi::c_void) -> u16);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_call_tx_callbacks(port_id : u16, queue_id : u16, tx_pkts : *mut *mut super::mbuf:: rte_mbuf, nb_pkts : u16, opaque : *mut core::ffi::c_void) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_cman_config_get(port_id : u16, config : *mut rte_eth_cman_config) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_cman_config_init(port_id : u16, config : *mut rte_eth_cman_config) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_cman_config_set(port_id : u16, config : *const rte_eth_cman_config) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_cman_info_get(port_id : u16, info : *mut rte_eth_cman_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_adjust_nb_rx_tx_desc(port_id : u16, nb_rx_desc : *mut u16, nb_tx_desc : *mut u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_callback_register(port_id : u16, event : rte_eth_event_type, cb_fn : rte_eth_dev_cb_fn, cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_callback_unregister(port_id : u16, event : rte_eth_event_type, cb_fn : rte_eth_dev_cb_fn, cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_capability_name(capability : u64) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_close(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_conf_get(port_id : u16, dev_conf : *mut rte_eth_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_configure(port_id : u16, nb_rx_queue : u16, nb_tx_queue : u16, eth_conf : *const rte_eth_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_count_aggr_ports(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_count_avail() -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_count_total() -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_default_mac_addr_set(port_id : u16, mac_addr : *mut rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_flow_ctrl_get(port_id : u16, fc_conf : *mut rte_eth_fc_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_flow_ctrl_set(port_id : u16, fc_conf : *mut rte_eth_fc_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_fw_version_get(port_id : u16, fw_version : *mut i8, fw_size : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_dcb_info(port_id : u16, dcb_info : *mut rte_eth_dcb_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_eeprom(port_id : u16, info : *mut rte_dev_eeprom_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_eeprom_length(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_module_eeprom(port_id : u16, info : *mut rte_dev_eeprom_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_module_info(port_id : u16, modinfo : *mut rte_eth_dev_module_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_mtu(port_id : u16, mtu : *mut u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_name_by_port(port_id : u16, name : *mut i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_port_by_name(name : *const i8, port_id : *mut u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_reg_info(port_id : u16, info : *mut rte_dev_reg_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_reg_info_ext(port_id : u16, info : *mut rte_dev_reg_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_sec_ctx(port_id : u16) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_supported_ptypes(port_id : u16, ptype_mask : u32, ptypes : *mut u32, num : i32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_get_vlan_offload(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_hairpin_capability_get(port_id : u16, cap : *mut rte_eth_hairpin_cap) -> i32);
#[cfg(feature = "mempool")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_info_get(port_id : u16, dev_info : *mut rte_eth_dev_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_is_removed(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_is_valid_port(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_mac_addr_add(port_id : u16, mac_addr : *mut rte_ether_addr, pool : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_mac_addr_remove(port_id : u16, mac_addr : *mut rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_map_aggr_tx_affinity(port_id : u16, tx_queue_id : u16, affinity : u8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_owner_delete(owner_id : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_owner_get(port_id : u16, owner : *mut rte_eth_dev_owner) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_owner_new(owner_id : *mut u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_owner_set(port_id : u16, owner : *const rte_eth_dev_owner) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_owner_unset(port_id : u16, owner_id : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_pool_ops_supported(port_id : u16, pool : *const i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_priority_flow_ctrl_queue_configure(port_id : u16, pfc_queue_conf : *mut rte_eth_pfc_queue_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_priority_flow_ctrl_queue_info_get(port_id : u16, pfc_queue_info : *mut rte_eth_pfc_queue_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_priority_flow_ctrl_set(port_id : u16, pfc_conf : *mut rte_eth_pfc_conf) -> i32);
#[cfg(feature = "lcore")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_priv_dump(port_id : u16, file : *mut _IO_FILE) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_reset(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rss_algo_name(rss_algo : rte_eth_hash_function) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rss_hash_conf_get(port_id : u16, rss_conf : *mut rte_eth_rss_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rss_hash_update(port_id : u16, rss_conf : *mut rte_eth_rss_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rss_reta_query(port_id : u16, reta_conf : *mut rte_eth_rss_reta_entry64, reta_size : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rss_reta_update(port_id : u16, reta_conf : *mut rte_eth_rss_reta_entry64, reta_size : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_intr_ctl(port_id : u16, epfd : i32, op : i32, data : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_intr_ctl_q(port_id : u16, queue_id : u16, epfd : i32, op : i32, data : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id : u16, queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_intr_disable(port_id : u16, queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_intr_enable(port_id : u16, queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_offload_name(offload : u64) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_queue_start(port_id : u16, rx_queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_rx_queue_stop(port_id : u16, rx_queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_eeprom(port_id : u16, info : *mut rte_dev_eeprom_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_link_down(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_link_up(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_mc_addr_list(port_id : u16, mc_addr_set : *mut rte_ether_addr, nb_mc_addr : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_mtu(port_id : u16, mtu : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_ptypes(port_id : u16, ptype_mask : u32, set_ptypes : *mut u32, num : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_rx_queue_stats_mapping(port_id : u16, rx_queue_id : u16, stat_idx : u8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_tx_queue_stats_mapping(port_id : u16, tx_queue_id : u16, stat_idx : u8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_vlan_ether_type(port_id : u16, vlan_type : rte_vlan_type, tag_type : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_vlan_offload(port_id : u16, offload_mask : i32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_vlan_pvid(port_id : u16, pvid : u16, on : i32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_set_vlan_strip_on_queue(port_id : u16, rx_queue_id : u16, on : i32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_socket_id(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_start(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_stop(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_tx_offload_name(offload : u64) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_tx_queue_start(port_id : u16, tx_queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_tx_queue_stop(port_id : u16, tx_queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_uc_all_hash_table_set(port_id : u16, on : u8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_uc_hash_table_set(port_id : u16, addr : *mut rte_ether_addr, on : u8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_udp_tunnel_port_add(port_id : u16, tunnel_udp : *mut rte_eth_udp_tunnel) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_udp_tunnel_port_delete(port_id : u16, tunnel_udp : *mut rte_eth_udp_tunnel) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_dev_vlan_filter(port_id : u16, vlan_id : u16, on : i32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_fec_get(port_id : u16, fec_capa : *mut u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_fec_get_capability(port_id : u16, speed_fec_capa : *mut rte_eth_fec_capa, num : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_fec_set(port_id : u16, fec_capa : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_find_next(port_id : u16) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_find_next_of(port_id_start : u16, parent : *const core::ffi::c_void) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_find_next_owned_by(port_id : u16, owner_id : u64) -> u64);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_find_next_sibling(port_id_start : u16, ref_port_id : u16) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_find_rss_algo(name : *const i8, algo : *mut u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_get_monitor_addr(port_id : u16, queue_id : u16, pmc : *mut rte_power_monitor_cond) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_hairpin_bind(tx_port : u16, rx_port : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_hairpin_get_peer_ports(port_id : u16, peer_ports : *mut u16, len : u64, direction : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_hairpin_unbind(tx_port : u16, rx_port : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_ip_reassembly_capability_get(port_id : u16, capa : *mut rte_eth_ip_reassembly_params) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_ip_reassembly_conf_get(port_id : u16, conf : *mut rte_eth_ip_reassembly_params) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_ip_reassembly_conf_set(port_id : u16, conf : *const rte_eth_ip_reassembly_params) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_iterator_cleanup(iter : *mut rte_dev_iterator));
windows_link::link!("dpdk_dummy" "C" fn rte_eth_iterator_init(iter : *mut rte_dev_iterator, devargs : *const i8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_iterator_next(iter : *mut rte_dev_iterator) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_led_off(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_led_on(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_link_connector_to_str(link_connector : rte_eth_link_connector) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_link_get(port_id : u16, link : *mut rte_eth_link) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_link_get_nowait(port_id : u16, link : *mut rte_eth_link) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_link_speed_to_str(link_speed : u32) -> *mut i8);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_link_to_str(str : *mut i8, len : u64, eth_link : *const rte_eth_link) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_macaddr_get(port_id : u16, mac_addr : *mut rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_macaddrs_get(port_id : u16, ma : *mut rte_ether_addr, num : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_promiscuous_disable(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_promiscuous_enable(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_promiscuous_get(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_random_addr(addr : *mut u8));
windows_link::link!("dpdk_dummy" "C" fn rte_eth_read_clock(port_id : u16, clock : *mut u64) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_recycle_mbufs(rx_port_id : u16, rx_queue_id : u16, tx_port_id : u16, tx_queue_id : u16, recycle_rxq_info : *mut rte_eth_recycle_rxq_info) -> u16);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_recycle_rx_queue_info_get(port_id : u16, queue_id : u16, recycle_rxq_info : *mut rte_eth_recycle_rxq_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_remove_rx_callback(port_id : u16, queue_id : u16, user_cb : *const core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_remove_tx_callback(port_id : u16, queue_id : u16, user_cb : *const core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_representor_info_get(port_id : u16, info : *mut rte_eth_representor_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rss_hf_refine(rss_hf : u64) -> u64);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_avail_thresh_query(port_id : u16, queue_id : *mut u16, avail_thresh : *mut u8) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_avail_thresh_set(port_id : u16, queue_id : u16, avail_thresh : u8) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_burst(port_id : u16, queue_id : u16, rx_pkts : *mut *mut super::mbuf:: rte_mbuf, nb_pkts : u16) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_burst_mode_get(port_id : u16, queue_id : u16, mode : *mut rte_eth_burst_mode) -> i32);
#[cfg(feature = "lcore")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_descriptor_dump(port_id : u16, queue_id : u16, offset : u16, num : u16, file : *mut _IO_FILE) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_descriptor_status(port_id : u16, queue_id : u16, offset : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_hairpin_queue_setup(port_id : u16, rx_queue_id : u16, nb_rx_desc : u16, conf : *const rte_eth_hairpin_conf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_metadata_negotiate(port_id : u16, features : *mut u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_queue_count(port_id : u16, queue_id : u16) -> i32);
#[cfg(feature = "mempool")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_queue_info_get(port_id : u16, queue_id : u16, qinfo : *mut rte_eth_rxq_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_queue_is_valid(port_id : u16, queue_id : u16) -> i32);
#[cfg(feature = "mempool")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_rx_queue_setup(port_id : u16, rx_queue_id : u16, nb_rx_desc : u16, socket_id : u32, rx_conf : *const rte_eth_rxconf, mb_pool : *mut super::mempool:: rte_mempool) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_set_queue_rate_limit(port_id : u16, queue_idx : u16, tx_rate : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_speed_bitflag(speed : u32, duplex : i32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_speed_lanes_get(port_id : u16, lanes : *mut u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_speed_lanes_get_capability(port_id : u16, speed_lanes_capa : *mut rte_eth_speed_lanes_capa, num : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_speed_lanes_set(port_id : u16, speed_lanes : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_stats_get(port_id : u16, stats : *mut rte_eth_stats) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_stats_reset(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_adjust_freq(port_id : u16, ppm : i64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_adjust_time(port_id : u16, delta : i64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_disable(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_enable(port_id : u16) -> i32);
#[cfg(feature = "eal")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_read_rx_timestamp(port_id : u16, timestamp : *mut super::eal:: timespec, flags : u32) -> i32);
#[cfg(feature = "eal")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_read_time(port_id : u16, time : *mut super::eal:: timespec) -> i32);
#[cfg(feature = "eal")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_read_tx_timestamp(port_id : u16, timestamp : *mut super::eal:: timespec) -> i32);
#[cfg(feature = "eal")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_timesync_write_time(port_id : u16, time : *const super::eal:: timespec) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_buffer(port_id : u16, queue_id : u16, buffer : *mut rte_eth_dev_tx_buffer, tx_pkt : *mut super::mbuf:: rte_mbuf) -> u16);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_buffer_count_callback(pkts : *mut *mut super::mbuf:: rte_mbuf, unsent : u16, userdata : *mut core::ffi::c_void));
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_buffer_drop_callback(pkts : *mut *mut super::mbuf:: rte_mbuf, unsent : u16, userdata : *mut core::ffi::c_void));
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_buffer_flush(port_id : u16, queue_id : u16, buffer : *mut rte_eth_dev_tx_buffer) -> u16);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_buffer_init(buffer : *mut rte_eth_dev_tx_buffer, size : u16) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_buffer_set_err_callback(buffer : *mut rte_eth_dev_tx_buffer, callback : buffer_tx_error_fn, userdata : *mut core::ffi::c_void) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_burst(port_id : u16, queue_id : u16, tx_pkts : *mut *mut super::mbuf:: rte_mbuf, nb_pkts : u16) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_burst_mode_get(port_id : u16, queue_id : u16, mode : *mut rte_eth_burst_mode) -> i32);
#[cfg(feature = "lcore")]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_descriptor_dump(port_id : u16, queue_id : u16, offset : u16, num : u16, file : *mut _IO_FILE) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_descriptor_status(port_id : u16, queue_id : u16, offset : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_done_cleanup(port_id : u16, queue_id : u16, free_cnt : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_hairpin_queue_setup(port_id : u16, tx_queue_id : u16, nb_tx_desc : u16, conf : *const rte_eth_hairpin_conf) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_prepare(port_id : u16, queue_id : u16, tx_pkts : *mut *mut super::mbuf:: rte_mbuf, nb_pkts : u16) -> u16);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_queue_count(port_id : u16, queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_queue_info_get(port_id : u16, queue_id : u16, qinfo : *mut rte_eth_txq_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_queue_is_valid(port_id : u16, queue_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_tx_queue_setup(port_id : u16, tx_queue_id : u16, nb_tx_desc : u16, socket_id : u32, tx_conf : *const rte_eth_txconf) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_get(port_id : u16, xstats : *mut rte_eth_xstat, n : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_get_by_id(port_id : u16, ids : *const u64, values : *mut u64, size : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_get_id_by_name(port_id : u16, xstat_name : *const i8, id : *mut u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_get_names(port_id : u16, xstats_names : *mut rte_eth_xstat_name, size : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_get_names_by_id(port_id : u16, xstats_names : *mut rte_eth_xstat_name, size : u32, ids : *mut u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_query_state(port_id : u16, id : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_reset(port_id : u16) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_eth_xstats_set_counter(port_id : u16, id : u64, on_off : i32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ether_addr_copy(ea_from : *const rte_ether_addr, ea_to : *mut rte_ether_addr));
windows_link::link!("dpdk_dummy" "C" fn rte_ether_format_addr(buf : *mut i8, size : u16, eth_addr : *const rte_ether_addr));
windows_link::link!("dpdk_dummy" "C" fn rte_ether_unformat_addr(str : *const i8, eth_addr : *mut rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_broadcast_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_local_admin_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_multicast_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_same_ether_addr(ea1 : *const rte_ether_addr, ea2 : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_unicast_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_universal_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_valid_assigned_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_is_zero_ether_addr(ea : *const rte_ether_addr) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_power_monitor(pmc : *const rte_power_monitor_cond, tsc_timestamp : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_power_monitor_multi(pmc : *mut rte_power_monitor_cond, num : u32, tsc_timestamp : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_power_monitor_wakeup(lcore_id : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_power_pause(tsc_timestamp : u64) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_vlan_insert(m : *mut *mut super::mbuf:: rte_mbuf) -> i32);
#[cfg(all(feature = "mbuf", feature = "mempool"))]
windows_link::link!("dpdk_dummy" "C" fn rte_vlan_strip(m : *mut super::mbuf:: rte_mbuf) -> i32);
pub const RTE_CMAN_RED: u32 = 1u32;
pub const RTE_DEVTYPE_ALLOWED: u32 = 0u32;
pub const RTE_DEVTYPE_BLOCKED: u32 = 1u32;
pub const RTE_DEVTYPE_VIRTUAL: u32 = 2u32;
pub const RTE_DEV_ALLOWED: u32 = 0u32;
pub const RTE_DEV_BLOCKED: u32 = 1u32;
pub const RTE_DEV_EVENT_ADD: u32 = 0u32;
pub const RTE_DEV_EVENT_MAX: u32 = 2u32;
pub const RTE_DEV_EVENT_REMOVE: u32 = 1u32;
pub const RTE_DEV_NAME_MAX_LEN: i32 = 64i32;
pub const RTE_ETHER_ADDR_FMT_SIZE: i32 = 18i32;
pub const RTE_ETHER_ADDR_LEN: i32 = 6i32;
pub const RTE_ETHER_CRC_LEN: i32 = 4i32;
pub const RTE_ETHER_GROUP_ADDR: i32 = 1i32;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: i32 = 2i32;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: i32 = 16128i32;
pub const RTE_ETHER_MAX_LEN: i32 = 1518i32;
pub const RTE_ETHER_MAX_VLAN_ID: i32 = 4095i32;
pub const RTE_ETHER_MIN_LEN: i32 = 64i32;
pub const RTE_ETHER_MIN_MTU: i32 = 68i32;
pub const RTE_ETHER_TYPE_1588: i32 = 35063i32;
pub const RTE_ETHER_TYPE_ARP: i32 = 2054i32;
pub const RTE_ETHER_TYPE_ECPRI: i32 = 44798i32;
pub const RTE_ETHER_TYPE_ETAG: i32 = 35135i32;
pub const RTE_ETHER_TYPE_IPV4: i32 = 2048i32;
pub const RTE_ETHER_TYPE_IPV6: i32 = 34525i32;
pub const RTE_ETHER_TYPE_LEN: i32 = 2i32;
pub const RTE_ETHER_TYPE_LLDP: i32 = 35020i32;
pub const RTE_ETHER_TYPE_MPLS: i32 = 34887i32;
pub const RTE_ETHER_TYPE_MPLSM: i32 = 34888i32;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: i32 = 34915i32;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: i32 = 34916i32;
pub const RTE_ETHER_TYPE_QINQ: i32 = 34984i32;
pub const RTE_ETHER_TYPE_QINQ1: i32 = 37120i32;
pub const RTE_ETHER_TYPE_QINQ2: i32 = 37376i32;
pub const RTE_ETHER_TYPE_QINQ3: i32 = 37632i32;
pub const RTE_ETHER_TYPE_RARP: i32 = 32821i32;
pub const RTE_ETHER_TYPE_SLOW: i32 = 34825i32;
pub const RTE_ETHER_TYPE_TEB: i32 = 25944i32;
pub const RTE_ETHER_TYPE_VLAN: i32 = 33024i32;
pub const RTE_ETH_16_POOLS: u32 = 16u32;
pub const RTE_ETH_32_POOLS: u32 = 32u32;
pub const RTE_ETH_4_TCS: u32 = 4u32;
pub const RTE_ETH_64_POOLS: u32 = 64u32;
pub const RTE_ETH_8_POOLS: u32 = 8u32;
pub const RTE_ETH_8_TCS: u32 = 8u32;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: i32 = 1024i32;
pub const RTE_ETH_CMAN_OBJ_RX_QUEUE: u32 = 1u32;
pub const RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL: u32 = 2u32;
pub const RTE_ETH_DCB_NUM_QUEUES: i32 = 128i32;
pub const RTE_ETH_DCB_NUM_TCS: i32 = 8i32;
pub const RTE_ETH_DCB_NUM_USER_PRIORITIES: i32 = 8i32;
pub const RTE_ETH_DEV_ATTACHED: u32 = 1u32;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: i32 = 1i32;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: i32 = 512i32;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: i32 = 1i32;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: i32 = 512i32;
pub const RTE_ETH_DEV_NO_OWNER: i32 = 0i32;
pub const RTE_ETH_DEV_REMOVED: u32 = 2u32;
pub const RTE_ETH_DEV_UNUSED: u32 = 0u32;
pub const RTE_ETH_ERROR_HANDLE_MODE_NONE: u32 = 0u32;
pub const RTE_ETH_ERROR_HANDLE_MODE_PASSIVE: u32 = 1u32;
pub const RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE: u32 = 2u32;
pub const RTE_ETH_EVENT_DESTROY: u32 = 8u32;
pub const RTE_ETH_EVENT_ERR_RECOVERING: u32 = 12u32;
pub const RTE_ETH_EVENT_FLOW_AGED: u32 = 10u32;
pub const RTE_ETH_EVENT_INTR_LSC: u32 = 1u32;
pub const RTE_ETH_EVENT_INTR_RESET: u32 = 3u32;
pub const RTE_ETH_EVENT_INTR_RMV: u32 = 6u32;
pub const RTE_ETH_EVENT_IPSEC: u32 = 9u32;
pub const RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW: i32 = 1i32;
pub const RTE_ETH_EVENT_IPSEC_MAX: i32 = 7i32;
pub const RTE_ETH_EVENT_IPSEC_PMD_ERROR_END: i32 = -1i32;
pub const RTE_ETH_EVENT_IPSEC_PMD_ERROR_START: i32 = -256i32;
pub const RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY: i32 = 3i32;
pub const RTE_ETH_EVENT_IPSEC_SA_BYTE_HARD_EXPIRY: i32 = 5i32;
pub const RTE_ETH_EVENT_IPSEC_SA_PKT_EXPIRY: i32 = 4i32;
pub const RTE_ETH_EVENT_IPSEC_SA_PKT_HARD_EXPIRY: i32 = 6i32;
pub const RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY: i32 = 2i32;
pub const RTE_ETH_EVENT_IPSEC_UNKNOWN: i32 = 0i32;
pub const RTE_ETH_EVENT_MACSEC: u32 = 5u32;
pub const RTE_ETH_EVENT_MACSEC_RX_SA_PN_HARD_EXP: u32 = 2u32;
pub const RTE_ETH_EVENT_MACSEC_RX_SA_PN_SOFT_EXP: u32 = 3u32;
pub const RTE_ETH_EVENT_MACSEC_SA_NOT_VALID: u32 = 6u32;
pub const RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR: u32 = 1u32;
pub const RTE_ETH_EVENT_MACSEC_TX_SA_PN_HARD_EXP: u32 = 4u32;
pub const RTE_ETH_EVENT_MACSEC_TX_SA_PN_SOFT_EXP: u32 = 5u32;
pub const RTE_ETH_EVENT_MACSEC_UNKNOWN: u32 = 0u32;
pub const RTE_ETH_EVENT_MAX: u32 = 15u32;
pub const RTE_ETH_EVENT_NEW: u32 = 7u32;
pub const RTE_ETH_EVENT_QUEUE_STATE: u32 = 2u32;
pub const RTE_ETH_EVENT_RECOVERY_FAILED: u32 = 14u32;
pub const RTE_ETH_EVENT_RECOVERY_SUCCESS: u32 = 13u32;
pub const RTE_ETH_EVENT_RX_AVAIL_THRESH: u32 = 11u32;
pub const RTE_ETH_EVENT_UNKNOWN: u32 = 0u32;
pub const RTE_ETH_EVENT_VF_MBOX: u32 = 4u32;
pub const RTE_ETH_FC_FULL: u32 = 3u32;
pub const RTE_ETH_FC_NONE: u32 = 0u32;
pub const RTE_ETH_FC_RX_PAUSE: u32 = 1u32;
pub const RTE_ETH_FC_TX_PAUSE: u32 = 2u32;
pub const RTE_ETH_FEC_AUTO: u32 = 1u32;
pub const RTE_ETH_FEC_BASER: u32 = 2u32;
pub const RTE_ETH_FEC_LLRS: u32 = 4u32;
pub const RTE_ETH_FEC_NOFEC: u32 = 0u32;
pub const RTE_ETH_FEC_RS: u32 = 3u32;
pub const RTE_ETH_FLOW_FRAG_IPV4: i32 = 3i32;
pub const RTE_ETH_FLOW_FRAG_IPV6: i32 = 9i32;
pub const RTE_ETH_FLOW_GENEVE: i32 = 20i32;
pub const RTE_ETH_FLOW_GTPU: i32 = 23i32;
pub const RTE_ETH_FLOW_IPV4: i32 = 2i32;
pub const RTE_ETH_FLOW_IPV6: i32 = 8i32;
pub const RTE_ETH_FLOW_IPV6_EX: i32 = 15i32;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: i32 = 16i32;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: i32 = 17i32;
pub const RTE_ETH_FLOW_L2_PAYLOAD: i32 = 14i32;
pub const RTE_ETH_FLOW_MAX: i32 = 24i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: i32 = 7i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: i32 = 6i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: i32 = 4i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: i32 = 5i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: i32 = 13i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: i32 = 12i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: i32 = 10i32;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: i32 = 11i32;
pub const RTE_ETH_FLOW_NVGRE: i32 = 21i32;
pub const RTE_ETH_FLOW_PORT: i32 = 18i32;
pub const RTE_ETH_FLOW_RAW: i32 = 1i32;
pub const RTE_ETH_FLOW_UNKNOWN: i32 = 0i32;
pub const RTE_ETH_FLOW_VXLAN: i32 = 19i32;
pub const RTE_ETH_FLOW_VXLAN_GPE: i32 = 22i32;
pub const RTE_ETH_HASH_FUNCTION_DEFAULT: u32 = 0u32;
pub const RTE_ETH_HASH_FUNCTION_MAX: u32 = 5u32;
pub const RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: u32 = 2u32;
pub const RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: u32 = 3u32;
pub const RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT: u32 = 4u32;
pub const RTE_ETH_HASH_FUNCTION_TOEPLITZ: u32 = 1u32;
pub const RTE_ETH_L2_TUNNEL_TYPE_E_TAG: u32 = 6u32;
pub const RTE_ETH_LINK_AUTONEG: i32 = 1i32;
pub const RTE_ETH_LINK_CONNECTOR_AUI: u32 = 2u32;
pub const RTE_ETH_LINK_CONNECTOR_BNC: u32 = 5u32;
pub const RTE_ETH_LINK_CONNECTOR_CAUI: u32 = 14u32;
pub const RTE_ETH_LINK_CONNECTOR_DAC: u32 = 6u32;
pub const RTE_ETH_LINK_CONNECTOR_FIBER: u32 = 4u32;
pub const RTE_ETH_LINK_CONNECTOR_GAUI: u32 = 12u32;
pub const RTE_ETH_LINK_CONNECTOR_LAUI: u32 = 15u32;
pub const RTE_ETH_LINK_CONNECTOR_MII: u32 = 3u32;
pub const RTE_ETH_LINK_CONNECTOR_NONE: u32 = 0u32;
pub const RTE_ETH_LINK_CONNECTOR_OTHER: u32 = 63u32;
pub const RTE_ETH_LINK_CONNECTOR_QSFP: u32 = 20u32;
pub const RTE_ETH_LINK_CONNECTOR_QSFP28: u32 = 22u32;
pub const RTE_ETH_LINK_CONNECTOR_QSFP56: u32 = 23u32;
pub const RTE_ETH_LINK_CONNECTOR_QSFP_DD: u32 = 24u32;
pub const RTE_ETH_LINK_CONNECTOR_QSFP_PLUS: u32 = 21u32;
pub const RTE_ETH_LINK_CONNECTOR_QSGMII: u32 = 8u32;
pub const RTE_ETH_LINK_CONNECTOR_SFI: u32 = 10u32;
pub const RTE_ETH_LINK_CONNECTOR_SFP: u32 = 16u32;
pub const RTE_ETH_LINK_CONNECTOR_SFP28: u32 = 18u32;
pub const RTE_ETH_LINK_CONNECTOR_SFP_DD: u32 = 19u32;
pub const RTE_ETH_LINK_CONNECTOR_SFP_PLUS: u32 = 17u32;
pub const RTE_ETH_LINK_CONNECTOR_SGMII: u32 = 7u32;
pub const RTE_ETH_LINK_CONNECTOR_TP: u32 = 1u32;
pub const RTE_ETH_LINK_CONNECTOR_XAUI: u32 = 13u32;
pub const RTE_ETH_LINK_CONNECTOR_XFI: u32 = 9u32;
pub const RTE_ETH_LINK_CONNECTOR_XLAUI: u32 = 11u32;
pub const RTE_ETH_LINK_DOWN: i32 = 0i32;
pub const RTE_ETH_LINK_FIXED: i32 = 0i32;
pub const RTE_ETH_LINK_FULL_DUPLEX: i32 = 1i32;
pub const RTE_ETH_LINK_HALF_DUPLEX: i32 = 0i32;
pub const RTE_ETH_LINK_MAX_STR_LEN: i32 = 40i32;
pub const RTE_ETH_LINK_SPEED_AUTONEG: i32 = 0i32;
pub const RTE_ETH_LINK_UP: i32 = 1i32;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: i32 = 32i32;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: i32 = 64i32;
pub const RTE_ETH_MAX_VMDQ_POOL: i32 = 64i32;
pub const RTE_ETH_MODULE_SFF_8079: i32 = 1i32;
pub const RTE_ETH_MODULE_SFF_8079_LEN: i32 = 256i32;
pub const RTE_ETH_MODULE_SFF_8436: i32 = 4i32;
pub const RTE_ETH_MODULE_SFF_8436_LEN: i32 = 256i32;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: i32 = 640i32;
pub const RTE_ETH_MODULE_SFF_8472: i32 = 2i32;
pub const RTE_ETH_MODULE_SFF_8472_LEN: i32 = 512i32;
pub const RTE_ETH_MODULE_SFF_8636: i32 = 3i32;
pub const RTE_ETH_MODULE_SFF_8636_LEN: i32 = 256i32;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: i32 = 640i32;
pub const RTE_ETH_MQ_RX_DCB: u32 = 2u32;
pub const RTE_ETH_MQ_RX_DCB_RSS: u32 = 3u32;
pub const RTE_ETH_MQ_RX_NONE: u32 = 0u32;
pub const RTE_ETH_MQ_RX_RSS: u32 = 1u32;
pub const RTE_ETH_MQ_RX_VMDQ_DCB: u32 = 6u32;
pub const RTE_ETH_MQ_RX_VMDQ_DCB_RSS: u32 = 7u32;
pub const RTE_ETH_MQ_RX_VMDQ_ONLY: u32 = 4u32;
pub const RTE_ETH_MQ_RX_VMDQ_RSS: u32 = 5u32;
pub const RTE_ETH_MQ_TX_DCB: u32 = 1u32;
pub const RTE_ETH_MQ_TX_NONE: u32 = 0u32;
pub const RTE_ETH_MQ_TX_VMDQ_DCB: u32 = 2u32;
pub const RTE_ETH_MQ_TX_VMDQ_ONLY: u32 = 3u32;
pub const RTE_ETH_NUM_RECEIVE_MAC_ADDR: i32 = 128i32;
pub const RTE_ETH_QINQ_STRIP_MASK: i32 = 8i32;
pub const RTE_ETH_QINQ_STRIP_OFFLOAD: i32 = 8i32;
pub const RTE_ETH_QUEUE_STATE_HAIRPIN: i32 = 2i32;
pub const RTE_ETH_QUEUE_STATE_STARTED: i32 = 1i32;
pub const RTE_ETH_QUEUE_STATE_STOPPED: i32 = 0i32;
pub const RTE_ETH_REG_NAME_SIZE: i32 = 64i32;
pub const RTE_ETH_REPRESENTOR_NONE: u32 = 0u32;
pub const RTE_ETH_REPRESENTOR_PF: u32 = 3u32;
pub const RTE_ETH_REPRESENTOR_SF: u32 = 2u32;
pub const RTE_ETH_REPRESENTOR_VF: u32 = 1u32;
pub const RTE_ETH_RETA_GROUP_SIZE: i32 = 64i32;
pub const RTE_ETH_RSS_RETA_SIZE_128: i32 = 128i32;
pub const RTE_ETH_RSS_RETA_SIZE_256: i32 = 256i32;
pub const RTE_ETH_RSS_RETA_SIZE_512: i32 = 512i32;
pub const RTE_ETH_RSS_RETA_SIZE_64: i32 = 64i32;
pub const RTE_ETH_RX_DESC_AVAIL: i32 = 0i32;
pub const RTE_ETH_RX_DESC_DONE: i32 = 1i32;
pub const RTE_ETH_RX_DESC_UNAVAIL: i32 = 2i32;
pub const RTE_ETH_SPEED_NUM_100G: i32 = 100000i32;
pub const RTE_ETH_SPEED_NUM_100M: i32 = 100i32;
pub const RTE_ETH_SPEED_NUM_10G: i32 = 10000i32;
pub const RTE_ETH_SPEED_NUM_10M: i32 = 10i32;
pub const RTE_ETH_SPEED_NUM_1G: i32 = 1000i32;
pub const RTE_ETH_SPEED_NUM_200G: i32 = 200000i32;
pub const RTE_ETH_SPEED_NUM_20G: i32 = 20000i32;
pub const RTE_ETH_SPEED_NUM_25G: i32 = 25000i32;
pub const RTE_ETH_SPEED_NUM_2_5G: i32 = 2500i32;
pub const RTE_ETH_SPEED_NUM_400G: i32 = 400000i32;
pub const RTE_ETH_SPEED_NUM_40G: i32 = 40000i32;
pub const RTE_ETH_SPEED_NUM_50G: i32 = 50000i32;
pub const RTE_ETH_SPEED_NUM_56G: i32 = 56000i32;
pub const RTE_ETH_SPEED_NUM_5G: i32 = 5000i32;
pub const RTE_ETH_SPEED_NUM_800G: i32 = 800000i32;
pub const RTE_ETH_SPEED_NUM_NONE: i32 = 0i32;
pub const RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_ES_EQ1_SC_EQ1: u32 = 4u32;
pub const RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_E_EQ0_C_EQ1: u32 = 2u32;
pub const RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SC_EQ1_SCB_EQ1: u32 = 5u32;
pub const RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SL_GTE48: u32 = 3u32;
pub const RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_V_EQ1: u32 = 1u32;
pub const RTE_ETH_SUBEVENT_MACSEC_UNKNOWN: u32 = 0u32;
pub const RTE_ETH_TUNNEL_TYPE_ECPRI: u32 = 8u32;
pub const RTE_ETH_TUNNEL_TYPE_GENEVE: u32 = 2u32;
pub const RTE_ETH_TUNNEL_TYPE_IP_IN_GRE: u32 = 5u32;
pub const RTE_ETH_TUNNEL_TYPE_MAX: u32 = 9u32;
pub const RTE_ETH_TUNNEL_TYPE_NONE: u32 = 0u32;
pub const RTE_ETH_TUNNEL_TYPE_NVGRE: u32 = 4u32;
pub const RTE_ETH_TUNNEL_TYPE_TEREDO: u32 = 3u32;
pub const RTE_ETH_TUNNEL_TYPE_VXLAN: u32 = 1u32;
pub const RTE_ETH_TUNNEL_TYPE_VXLAN_GPE: u32 = 7u32;
pub const RTE_ETH_TX_DESC_DONE: i32 = 1i32;
pub const RTE_ETH_TX_DESC_FULL: i32 = 0i32;
pub const RTE_ETH_TX_DESC_UNAVAIL: i32 = 2i32;
pub const RTE_ETH_VLAN_EXTEND_MASK: i32 = 4i32;
pub const RTE_ETH_VLAN_EXTEND_OFFLOAD: i32 = 4i32;
pub const RTE_ETH_VLAN_FILTER_MASK: i32 = 2i32;
pub const RTE_ETH_VLAN_FILTER_OFFLOAD: i32 = 2i32;
pub const RTE_ETH_VLAN_ID_MAX: i32 = 4095i32;
pub const RTE_ETH_VLAN_STRIP_MASK: i32 = 1i32;
pub const RTE_ETH_VLAN_STRIP_OFFLOAD: i32 = 1i32;
pub const RTE_ETH_VLAN_TYPE_INNER: u32 = 1u32;
pub const RTE_ETH_VLAN_TYPE_MAX: u32 = 3u32;
pub const RTE_ETH_VLAN_TYPE_OUTER: u32 = 2u32;
pub const RTE_ETH_VLAN_TYPE_UNKNOWN: u32 = 0u32;
pub const RTE_ETH_VMDQ_DCB_NUM_QUEUES: i32 = 128i32;
pub const RTE_ETH_VMDQ_MAX_VLAN_FILTERS: i32 = 64i32;
pub const RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY: i32 = 128i32;
pub const RTE_ETH_XSTATS_NAME_SIZE: i32 = 64i32;
pub const RTE_POWER_MONITOR_OPAQUE_SZ: i32 = 4i32;
pub const RTE_VLAN_DEI_MASK: i32 = 4096i32;
pub const RTE_VLAN_DEI_SHIFT: i32 = 12i32;
pub const RTE_VLAN_HLEN: i32 = 4i32;
pub const RTE_VLAN_ID_MASK: i32 = 4095i32;
pub const RTE_VLAN_PRI_MASK: i32 = 57344i32;
pub const RTE_VLAN_PRI_SHIFT: i32 = 13i32;
pub const _IO_EOF_SEEN: i32 = 16i32;
pub const _IO_ERR_SEEN: i32 = 32i32;
#[repr(C, packed(8))]
#[cfg(feature = "lcore")]
#[derive(Clone, Copy)]
pub struct _IO_FILE {
    pub _flags: i32,
    pub _IO_read_ptr: *mut i8,
    pub _IO_read_end: *mut i8,
    pub _IO_read_base: *mut i8,
    pub _IO_write_base: *mut i8,
    pub _IO_write_ptr: *mut i8,
    pub _IO_write_end: *mut i8,
    pub _IO_buf_base: *mut i8,
    pub _IO_buf_end: *mut i8,
    pub _IO_save_base: *mut i8,
    pub _IO_backup_base: *mut i8,
    pub _IO_save_end: *mut i8,
    pub _markers: *mut core::ffi::c_void,
    pub _chain: *mut _IO_FILE,
    pub _fileno: i32,
    pub _flags2: i32,
    pub _old_offset: i64,
    pub _cur_column: u16,
    pub _vtable_offset: i8,
    pub _shortbuf: [i8; 1],
    pub _lock: *mut super::lcore::_IO_lock_t,
    pub _offset: i64,
    pub _codecvt: *mut core::ffi::c_void,
    pub _wide_data: *mut core::ffi::c_void,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut core::ffi::c_void,
    pub __pad5: u64,
    pub _mode: i32,
    pub _unused2: [i8; 20],
}
#[cfg(feature = "lcore")]
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const _IO_USER_LOCK: i32 = 32768i32;
pub const __struct_FILE_defined: i32 = 1i32;
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type buffer_tx_error_fn = Option<
    unsafe extern "system" fn(
        param0: *const *const super::mbuf::rte_mbuf,
        param1: u16,
        param2: *const core::ffi::c_void,
    ),
>;
pub type eth_recycle_rx_descriptors_refill_t =
    Option<unsafe extern "system" fn(param0: *const core::ffi::c_void, param1: u16)>;
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type eth_recycle_tx_mbufs_reuse_t = Option<
    unsafe extern "system" fn(
        param0: *const core::ffi::c_void,
        param1: *const rte_eth_recycle_rxq_info,
    ) -> u16,
>;
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type eth_rx_burst_t = Option<
    unsafe extern "system" fn(
        param0: *const core::ffi::c_void,
        param1: *const *const super::mbuf::rte_mbuf,
        param2: u16,
    ) -> u16,
>;
pub type eth_rx_descriptor_status_t =
    Option<unsafe extern "system" fn(param0: *const core::ffi::c_void, param1: u16) -> i32>;
pub type eth_rx_queue_count_t =
    Option<unsafe extern "system" fn(param0: *const core::ffi::c_void) -> i32>;
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type eth_tx_burst_t = Option<
    unsafe extern "system" fn(
        param0: *const core::ffi::c_void,
        param1: *const *const super::mbuf::rte_mbuf,
        param2: u16,
    ) -> u16,
>;
pub type eth_tx_descriptor_status_t =
    Option<unsafe extern "system" fn(param0: *const core::ffi::c_void, param1: u16) -> i32>;
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type eth_tx_prep_t = Option<
    unsafe extern "system" fn(
        param0: *const core::ffi::c_void,
        param1: *const *const super::mbuf::rte_mbuf,
        param2: u16,
    ) -> u16,
>;
pub type eth_tx_queue_count_t =
    Option<unsafe extern "system" fn(param0: *const core::ffi::c_void) -> i32>;
pub type rte_cman_mode = u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_cman_red_params {
    pub min_th: u8,
    pub max_th: u8,
    pub maxp_inv: u16,
}
pub type rte_dev_cmp_t = Option<
    unsafe extern "system" fn(
        param0: *const core::ffi::c_void,
        param1: *const core::ffi::c_void,
    ) -> i32,
>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_dev_eeprom_info {
    pub data: *mut core::ffi::c_void,
    pub offset: u32,
    pub length: u32,
    pub magic: u32,
}
impl Default for rte_dev_eeprom_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_dev_event_cb_fn = Option<
    unsafe extern "system" fn(
        param0: *const i8,
        param1: rte_dev_event_type,
        param2: *const core::ffi::c_void,
    ),
>;
pub type rte_dev_event_type = u32;
pub type rte_dev_iterate_t = Option<
    unsafe extern "system" fn(
        param0: *const core::ffi::c_void,
        param1: *const i8,
        param2: *const rte_dev_iterator,
    ) -> *mut core::ffi::c_void,
>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_dev_iterator {
    pub dev_str: *mut i8,
    pub bus_str: *mut i8,
    pub cls_str: *mut i8,
    pub bus: *mut core::ffi::c_void,
    pub cls: *mut core::ffi::c_void,
    pub device: *mut core::ffi::c_void,
    pub class_device: *mut core::ffi::c_void,
}
impl Default for rte_dev_iterator {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_dev_policy = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_dev_reg_info {
    pub data: *mut core::ffi::c_void,
    pub offset: u32,
    pub length: u32,
    pub width: u32,
    pub version: u32,
    pub filter: *mut i8,
    pub names: *mut rte_eth_reg_name,
}
impl Default for rte_dev_reg_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_devargs {
    pub next: rte_devargs_next,
    pub r#type: rte_devtype,
    pub policy: rte_dev_policy,
    pub name: [i8; 64],
    pub bus: *mut core::ffi::c_void,
    pub cls: *mut core::ffi::c_void,
    pub bus_str: *mut i8,
    pub cls_str: *mut i8,
    pub data: *mut i8,
}
impl Default for rte_devargs {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_devargs_next {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
impl Default for rte_devargs_next {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_devtype = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_burst_mode {
    pub flags: u64,
    pub info: [i8; 1024],
}
impl Default for rte_eth_burst_mode {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_cman_config {
    pub obj: rte_eth_cman_obj,
    pub mode: rte_cman_mode,
    pub obj_param: rte_eth_cman_config_obj_param,
    pub mode_param: rte_eth_cman_config_mode_param,
}
impl Default for rte_eth_cman_config {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub union rte_eth_cman_config_mode_param {
    pub red: rte_cman_red_params,
    pub rsvd_mode_params: [u8; 4],
}
impl Default for rte_eth_cman_config_mode_param {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub union rte_eth_cman_config_obj_param {
    pub rx_queue: u16,
    pub rsvd_obj_params: [u8; 4],
}
impl Default for rte_eth_cman_config_obj_param {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_cman_info {
    pub modes_supported: u64,
    pub objs_supported: u64,
    pub rsvd: [u8; 8],
}
impl Default for rte_eth_cman_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_eth_cman_obj = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_conf {
    pub link_speeds: u32,
    pub rxmode: rte_eth_rxmode,
    pub txmode: rte_eth_txmode,
    pub lpbk_mode: u32,
    pub rx_adv_conf: rte_eth_conf_rx_adv_conf,
    pub tx_adv_conf: rte_eth_conf_tx_adv_conf,
    pub dcb_capability_en: u32,
    pub intr_conf: rte_eth_intr_conf,
}
impl Default for rte_eth_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_conf_rx_adv_conf {
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub union rte_eth_conf_tx_adv_conf {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
impl Default for rte_eth_conf_tx_adv_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct rte_eth_dcb_info {
    pub nb_tcs: u8,
    pub prio_tc: [u8; 8],
    pub tc_bws: [u8; 8],
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
impl Default for rte_eth_dcb_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_dcb_rx_conf {
    pub nb_tcs: rte_eth_nb_tcs,
    pub dcb_tc: [u8; 8],
}
impl Default for rte_eth_dcb_rx_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping_tc_rxq; 8]; 64],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping_tc_txq; 8]; 64],
}
impl Default for rte_eth_dcb_tc_queue_mapping {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_dcb_tc_queue_mapping_tc_rxq {
    pub base: u16,
    pub nb_queue: u16,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_dcb_tc_queue_mapping_tc_txq {
    pub base: u16,
    pub nb_queue: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_dcb_tx_conf {
    pub nb_tcs: rte_eth_nb_tcs,
    pub dcb_tc: [u8; 8],
}
impl Default for rte_eth_dcb_tx_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_desc_lim {
    pub nb_max: u16,
    pub nb_min: u16,
    pub nb_align: u16,
    pub nb_seg_max: u16,
    pub nb_mtu_seg_max: u16,
}
pub type rte_eth_dev_cb_fn = Option<
    unsafe extern "system" fn(
        param0: u16,
        param1: rte_eth_event_type,
        param2: *const core::ffi::c_void,
        param3: *const core::ffi::c_void,
    ) -> i32,
>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut core::ffi::c_void,
    pub tqh_last: *mut *mut core::ffi::c_void,
}
impl Default for rte_eth_dev_cb_list {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[cfg(feature = "mempool")]
#[derive(Clone, Copy)]
pub struct rte_eth_dev_info {
    pub device: *mut core::ffi::c_void,
    pub driver_name: *mut i8,
    pub if_index: u32,
    pub min_mtu: u16,
    pub max_mtu: u16,
    pub dev_flags: *mut u32,
    pub min_rx_bufsize: u32,
    pub max_rx_bufsize: u32,
    pub max_rx_pktlen: u32,
    pub max_lro_pkt_size: u32,
    pub max_rx_queues: u16,
    pub max_tx_queues: u16,
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    pub max_vfs: u16,
    pub max_vmdq_pools: u16,
    pub rx_seg_capa: rte_eth_rxseg_capa,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    pub hash_key_size: u8,
    pub rss_algo_capa: u32,
    pub flow_type_rss_offloads: u64,
    pub default_rxconf: rte_eth_rxconf,
    pub default_txconf: rte_eth_txconf,
    pub vmdq_queue_base: u16,
    pub vmdq_queue_num: u16,
    pub vmdq_pool_base: u16,
    pub rx_desc_lim: rte_eth_desc_lim,
    pub tx_desc_lim: rte_eth_desc_lim,
    pub speed_capa: u32,
    pub nb_rx_queues: u16,
    pub nb_tx_queues: u16,
    pub max_rx_mempools: u16,
    pub default_rxportconf: rte_eth_dev_portconf,
    pub default_txportconf: rte_eth_dev_portconf,
    pub dev_capa: u64,
    pub switch_info: rte_eth_switch_info,
    pub err_handle_mode: rte_eth_err_handle_mode,
    pub reserved_64s: [u64; 2],
    pub reserved_ptrs: [*mut core::ffi::c_void; 2],
}
#[cfg(feature = "mempool")]
impl Default for rte_eth_dev_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_dev_module_info {
    pub r#type: u32,
    pub eeprom_len: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_dev_owner {
    pub id: u64,
    pub name: [i8; 64],
}
impl Default for rte_eth_dev_owner {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_dev_portconf {
    pub burst_size: u16,
    pub ring_size: u16,
    pub nb_queues: u16,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_dev_sriov {
    pub active: u8,
    pub nb_q_per_pool: u8,
    pub def_vmdq_idx: u16,
    pub def_pool_q_idx: u16,
}
pub type rte_eth_dev_state = u32;
#[repr(C, packed(8))]
#[cfg(all(feature = "mbuf", feature = "mempool"))]
#[derive(Clone, Copy)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut core::ffi::c_void,
    pub size: u16,
    pub length: u16,
    pub pkts: *mut *mut super::mbuf::rte_mbuf,
}
#[cfg(all(feature = "mbuf", feature = "mempool"))]
impl Default for rte_eth_dev_tx_buffer {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_eth_err_handle_mode = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_event_ipsec_desc {
    pub subtype: rte_eth_event_ipsec_subtype,
    pub metadata: u64,
}
pub type rte_eth_event_ipsec_subtype = i32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_event_macsec_desc {
    pub r#type: rte_eth_event_macsec_type,
    pub subtype: rte_eth_event_macsec_subtype,
    pub metadata: u64,
}
pub type rte_eth_event_macsec_subtype = u32;
pub type rte_eth_event_macsec_type = u32;
pub type rte_eth_event_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_fc_conf {
    pub high_water: u32,
    pub low_water: u32,
    pub pause_time: u16,
    pub send_xon: u16,
    pub mode: rte_eth_fc_mode,
    pub mac_ctrl_frame_fwd: u8,
    pub autoneg: u8,
}
pub type rte_eth_fc_mode = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_fec_capa {
    pub speed: u32,
    pub capa: u32,
}
pub type rte_eth_fec_mode = u32;
#[repr(C, packed(64))]
#[cfg(all(feature = "mbuf", feature = "mempool"))]
#[derive(Clone, Copy)]
pub struct rte_eth_fp_ops {
    pub rxq: rte_ethdev_qdata,
    pub rx_pkt_burst: eth_rx_burst_t,
    pub rx_queue_count: eth_rx_queue_count_t,
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    pub recycle_rx_descriptors_refill: eth_recycle_rx_descriptors_refill_t,
    pub reserved1: [u64; 2],
    pub txq: rte_ethdev_qdata,
    pub tx_pkt_burst: eth_tx_burst_t,
    pub tx_pkt_prepare: eth_tx_prep_t,
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    pub recycle_tx_mbufs_reuse: eth_recycle_tx_mbufs_reuse_t,
    pub tx_queue_count: eth_tx_queue_count_t,
    pub reserved2: [u64; 1],
}
#[cfg(all(feature = "mbuf", feature = "mempool"))]
impl Default for rte_eth_fp_ops {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_hairpin_cap {
    pub max_nb_queues: u16,
    pub max_rx_2_tx: u16,
    pub max_tx_2_rx: u16,
    pub max_nb_desc: u16,
    pub rx_cap: rte_eth_hairpin_queue_cap,
    pub tx_cap: rte_eth_hairpin_queue_cap,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_hairpin_conf {
    pub peer_count: u32,
    pub tx_explicit: u32,
    pub manual_bind: u32,
    pub use_locked_device_memory: u32,
    pub use_rte_memory: u32,
    pub force_memory: u32,
    pub reserved: u32,
    pub peers: [rte_eth_hairpin_peer; 32],
}
impl Default for rte_eth_hairpin_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_hairpin_peer {
    pub port: u16,
    pub queue: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_hairpin_queue_cap {
    pub locked_device_memory: u32,
    pub rte_memory: u32,
    pub reserved: u32,
}
pub type rte_eth_hash_function = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_intr_conf {
    pub lsc: u32,
    pub rxq: u32,
    pub rmv: u32,
}
#[repr(C, packed(8))]
#[cfg(all(feature = "mbuf", feature = "mempool"))]
#[derive(Clone, Copy)]
pub struct rte_eth_ip_reassembly_dynfield_t {
    pub next_frag: *mut super::mbuf::rte_mbuf,
    pub time_spent: u16,
    pub nb_frags: u16,
}
#[cfg(all(feature = "mbuf", feature = "mempool"))]
impl Default for rte_eth_ip_reassembly_dynfield_t {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_ip_reassembly_params {
    pub timeout_ms: u32,
    pub max_frags: u16,
    pub flags: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_link(pub u8);
pub type rte_eth_link_connector = u32;
pub type rte_eth_nb_pools = u32;
pub type rte_eth_nb_tcs = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_pfc_conf {
    pub fc: rte_eth_fc_conf,
    pub priority: u8,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_pfc_queue_conf {
    pub mode: rte_eth_fc_mode,
    pub rx_pause: rte_eth_pfc_queue_conf_rx_pause,
    pub tx_pause: rte_eth_pfc_queue_conf_tx_pause,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_pfc_queue_conf_rx_pause {
    pub tx_qid: u16,
    pub tc: u8,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_pfc_queue_conf_tx_pause {
    pub pause_time: u16,
    pub rx_qid: u16,
    pub tc: u8,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_pfc_queue_info {
    pub tc_max: u8,
    pub mode_capa: rte_eth_fc_mode,
}
#[repr(C, packed(64))]
#[cfg(all(feature = "mbuf", feature = "mempool"))]
#[derive(Clone, Copy)]
pub struct rte_eth_recycle_rxq_info {
    pub mbuf_ring: *mut *mut super::mbuf::rte_mbuf,
    pub mp: *mut super::mempool::rte_mempool,
    pub refill_head: *mut u16,
    pub receive_tail: *mut u16,
    pub mbuf_ring_size: u16,
    pub refill_requirement: u16,
}
#[cfg(all(feature = "mbuf", feature = "mempool"))]
impl Default for rte_eth_recycle_rxq_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[derive(Clone, Copy)]
pub struct rte_eth_reg_name {
    pub name: [i8; 64],
}
impl Default for rte_eth_reg_name {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_representor_info {
    pub controller: u16,
    pub pf: u16,
    pub nb_ranges_alloc: u32,
    pub nb_ranges: u32,
    pub ranges: *mut rte_eth_representor_range,
}
impl Default for rte_eth_representor_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_representor_range {
    pub r#type: rte_eth_representor_type,
    pub controller: i32,
    pub pf: i32,
    pub id_base: u32,
    pub id_end: u32,
    pub name: [i8; 64],
}
impl Default for rte_eth_representor_range {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_eth_representor_type = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_rss_conf {
    pub rss_key: *mut u8,
    pub rss_key_len: u8,
    pub rss_hf: u64,
    pub algorithm: rte_eth_hash_function,
}
impl Default for rte_eth_rss_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64],
}
impl Default for rte_eth_rss_reta_entry64 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_eth_rx_mq_mode = u32;
#[repr(C, packed(8))]
#[cfg(feature = "mempool")]
#[derive(Clone, Copy)]
pub struct rte_eth_rxconf {
    pub rx_thresh: rte_eth_thresh,
    pub rx_free_thresh: u16,
    pub rx_drop_en: u8,
    pub rx_deferred_start: u8,
    pub rx_nseg: u16,
    pub share_group: u16,
    pub share_qid: u16,
    pub offloads: u64,
    pub rx_seg: *mut rte_eth_rxseg,
    pub rx_mempools: *mut *mut super::mempool::rte_mempool,
    pub rx_nmempool: u16,
    pub reserved_64s: [u64; 2],
    pub reserved_ptrs: [*mut core::ffi::c_void; 2],
}
#[cfg(feature = "mempool")]
impl Default for rte_eth_rxconf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_rxmode {
    pub mq_mode: rte_eth_rx_mq_mode,
    pub mtu: u32,
    pub max_lro_pkt_size: u32,
    pub offloads: u64,
    pub reserved_64s: [u64; 2],
    pub reserved_ptrs: [*mut core::ffi::c_void; 2],
}
impl Default for rte_eth_rxmode {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(64))]
#[cfg(feature = "mempool")]
#[derive(Clone, Copy)]
pub struct rte_eth_rxq_info {
    pub mp: *mut super::mempool::rte_mempool,
    pub conf: rte_eth_rxconf,
    pub scattered_rx: u8,
    pub queue_state: u8,
    pub nb_desc: u16,
    pub rx_buf_size: u16,
    pub avail_thresh: u8,
}
#[cfg(feature = "mempool")]
impl Default for rte_eth_rxq_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[cfg(feature = "mempool")]
#[derive(Clone, Copy)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[cfg(feature = "mempool")]
impl Default for rte_eth_rxseg {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_rxseg_capa {
    pub multi_pools: u32,
    pub offset_allowed: u32,
    pub offset_align_log2: u32,
    pub max_nseg: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[cfg(feature = "mempool")]
#[derive(Clone, Copy)]
pub struct rte_eth_rxseg_split {
    pub mp: *mut super::mempool::rte_mempool,
    pub length: u16,
    pub offset: u16,
    pub proto_hdr: u32,
}
#[cfg(feature = "mempool")]
impl Default for rte_eth_rxseg_split {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_speed_lanes_capa {
    pub speed: u32,
    pub capa: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_stats {
    pub ipackets: u64,
    pub opackets: u64,
    pub ibytes: u64,
    pub obytes: u64,
    pub imissed: u64,
    pub ierrors: u64,
    pub oerrors: u64,
    pub rx_nombuf: u64,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_switch_info {
    pub name: *mut i8,
    pub domain_id: u16,
    pub port_id: u16,
    pub rx_domain: u16,
}
impl Default for rte_eth_switch_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_thresh {
    pub pthresh: u8,
    pub hthresh: u8,
    pub wthresh: u8,
}
pub type rte_eth_tunnel_type = u32;
pub type rte_eth_tx_mq_mode = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_txconf {
    pub tx_thresh: rte_eth_thresh,
    pub tx_rs_thresh: u16,
    pub tx_free_thresh: u16,
    pub tx_deferred_start: u8,
    pub offloads: u64,
    pub reserved_64s: [u64; 2],
    pub reserved_ptrs: [*mut core::ffi::c_void; 2],
}
impl Default for rte_eth_txconf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_txmode {
    pub mq_mode: rte_eth_tx_mq_mode,
    pub offloads: u64,
    pub pvid: u16,
    pub hw_vlan_reject_tagged: u8,
    pub hw_vlan_reject_untagged: u8,
    pub hw_vlan_insert_pvid: u8,
    pub reserved_64s: [u64; 2],
    pub reserved_ptrs: [*mut core::ffi::c_void; 2],
}
impl Default for rte_eth_txmode {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(64))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_txq_info {
    pub conf: rte_eth_txconf,
    pub nb_desc: u16,
    pub queue_state: u8,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_udp_tunnel {
    pub udp_port: u16,
    pub prot_type: u8,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_vmdq_dcb_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
    pub enable_default_pool: u8,
    pub default_pool: u8,
    pub nb_pool_maps: u8,
    pub pool_map: [rte_eth_vmdq_dcb_conf_pool_map; 64],
    pub dcb_tc: [u8; 8],
}
impl Default for rte_eth_vmdq_dcb_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_vmdq_dcb_conf_pool_map {
    pub vlan_id: u16,
    pub pools: u64,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
    pub dcb_tc: [u8; 8],
}
impl Default for rte_eth_vmdq_dcb_tx_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_eth_vmdq_rx_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
    pub enable_default_pool: u8,
    pub default_pool: u8,
    pub enable_loop_back: u8,
    pub nb_pool_maps: u8,
    pub rx_mode: u32,
    pub pool_map: [rte_eth_vmdq_rx_conf_pool_map; 64],
}
impl Default for rte_eth_vmdq_rx_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_vmdq_rx_conf_pool_map {
    pub vlan_id: u16,
    pub pools: u64,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_vmdq_tx_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct rte_eth_xstat {
    pub id: u64,
    pub value: u64,
}
#[repr(C, packed(1))]
#[derive(Clone, Copy)]
pub struct rte_eth_xstat_name {
    pub name: [i8; 64],
}
impl Default for rte_eth_xstat_name {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_ethdev_qdata {
    pub data: *mut *mut core::ffi::c_void,
    pub clbk: *mut *mut core::ffi::c_void,
}
impl Default for rte_ethdev_qdata {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct rte_ether_addr {
    pub addr_bytes: [u8; 6],
}
impl Default for rte_ether_addr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_ether_hdr {
    pub dst_addr: rte_ether_addr,
    pub src_addr: rte_ether_addr,
    pub ether_type: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mem_resource {
    pub phys_addr: u64,
    pub len: u64,
    pub addr: *mut core::ffi::c_void,
}
impl Default for rte_mem_resource {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_power_monitor_clb_t =
    Option<unsafe extern "system" fn(param0: u64, param1: [u64; 4]) -> i32>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_power_monitor_cond {
    pub addr: *mut core::ffi::c_void,
    pub size: u8,
    pub r#fn: rte_power_monitor_clb_t,
    pub opaque: [u64; 4],
}
impl Default for rte_power_monitor_cond {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type rte_rx_callback_fn = Option<
    unsafe extern "system" fn(
        param0: u16,
        param1: u16,
        param2: *const *const super::mbuf::rte_mbuf,
        param3: u16,
        param4: u16,
        param5: *const core::ffi::c_void,
    ) -> u16,
>;
#[cfg(all(feature = "mbuf", feature = "mempool"))]
pub type rte_tx_callback_fn = Option<
    unsafe extern "system" fn(
        param0: u16,
        param1: u16,
        param2: *const *const super::mbuf::rte_mbuf,
        param3: u16,
        param4: *const core::ffi::c_void,
    ) -> u16,
>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64],
}
impl Default for rte_vlan_filter_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct rte_vlan_hdr {
    pub vlan_tci: u16,
    pub eth_proto: u16,
}
pub type rte_vlan_type = u32;
