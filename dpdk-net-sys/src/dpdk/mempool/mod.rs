// Bindings generated by `windows-bindgen` 0.66.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]

windows_link::link!("dpdk_dummy" "C" fn rte_mempool_audit(mp : *mut rte_mempool));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_avail_count(mp : *const rte_mempool) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_cache_create(size : u32, socket_id : i32) -> *mut rte_mempool_cache);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_cache_flush(cache : *mut rte_mempool_cache, mp : *mut rte_mempool));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_cache_free(cache : *mut rte_mempool_cache));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_calc_obj_size(elt_size : u32, flags : u32, sz : *mut rte_mempool_objsz) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_check_cookies(mp : *const rte_mempool, obj_table_const : *const *const core::ffi::c_void, n : u32, free : i32));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_contig_blocks_check_cookies(mp : *const rte_mempool, first_obj_table_const : *const *const core::ffi::c_void, n : u32, free : i32));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_create(name : *const i8, n : u32, elt_size : u32, cache_size : u32, private_data_size : u32, mp_init : *mut rte_mempool_ctor_t, mp_init_arg : *mut core::ffi::c_void, obj_init : *mut rte_mempool_obj_cb_t, obj_init_arg : *mut core::ffi::c_void, socket_id : i32, flags : u32) -> *mut rte_mempool);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_create_empty(name : *const i8, n : u32, elt_size : u32, cache_size : u32, private_data_size : u32, socket_id : i32, flags : u32) -> *mut rte_mempool);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_default_cache(mp : *mut rte_mempool, lcore_id : u32) -> *mut rte_mempool_cache);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_do_generic_get(mp : *mut rte_mempool, obj_table : *mut *mut core::ffi::c_void, n : u32, cache : *mut rte_mempool_cache) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_do_generic_put(mp : *mut rte_mempool, obj_table : *const *const core::ffi::c_void, n : u32, cache : *mut rte_mempool_cache));
#[cfg(all(feature = "ethdev", feature = "lcore"))]
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_dump(f : *mut super::ethdev:: _IO_FILE, mp : *mut rte_mempool));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_empty(mp : *const rte_mempool) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_event_callback_register(func : *mut rte_mempool_event_callback, user_data : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_event_callback_unregister(func : *mut rte_mempool_event_callback, user_data : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_free(mp : *mut rte_mempool));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_from_obj(obj : *mut core::ffi::c_void) -> *mut rte_mempool);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_full(mp : *const rte_mempool) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_generic_get(mp : *mut rte_mempool, obj_table : *mut *mut core::ffi::c_void, n : u32, cache : *mut rte_mempool_cache) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_generic_put(mp : *mut rte_mempool, obj_table : *const *const core::ffi::c_void, n : u32, cache : *mut rte_mempool_cache));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get(mp : *mut rte_mempool, obj_p : *mut *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_bulk(mp : *mut rte_mempool, obj_table : *mut *mut core::ffi::c_void, n : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_contig_blocks(mp : *mut rte_mempool, first_obj_table : *mut *mut core::ffi::c_void, n : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_header(obj : *mut core::ffi::c_void) -> *mut rte_mempool_objhdr);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_mem_range(mp : *const rte_mempool, mem_range : *mut rte_mempool_mem_range_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_obj_alignment(mp : *const rte_mempool) -> u64);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_ops(ops_index : i32) -> *mut rte_mempool_ops);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_page_size(mp : *mut rte_mempool, pg_sz : *mut u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_priv(mp : *mut rte_mempool) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_get_trailer(obj : *mut core::ffi::c_void) -> *mut core::ffi::c_void);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_in_use_count(mp : *const rte_mempool) -> u32);
#[cfg(all(feature = "ethdev", feature = "lcore"))]
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_list_dump(f : *mut super::ethdev:: _IO_FILE));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_lookup(name : *const i8) -> *mut rte_mempool);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_mem_iter(mp : *mut rte_mempool, mem_cb : *mut rte_mempool_mem_cb_t, mem_cb_arg : *mut core::ffi::c_void) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_obj_iter(mp : *mut rte_mempool, obj_cb : *mut rte_mempool_obj_cb_t, obj_cb_arg : *mut core::ffi::c_void) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_op_calc_mem_size_default(mp : *const rte_mempool, obj_num : u32, pg_shift : u32, min_chunk_size : *mut u64, align : *mut u64) -> i64);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_op_calc_mem_size_helper(mp : *const rte_mempool, obj_num : u32, pg_shift : u32, chunk_reserve : u64, min_chunk_size : *mut u64, align : *mut u64) -> i64);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_op_populate_default(mp : *mut rte_mempool, max_objs : u32, vaddr : *mut core::ffi::c_void, iova : u64, len : u64, obj_cb : *mut rte_mempool_populate_obj_cb_t, obj_cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_op_populate_helper(mp : *mut rte_mempool, flags : u32, max_objs : u32, vaddr : *mut core::ffi::c_void, iova : u64, len : u64, obj_cb : *mut rte_mempool_populate_obj_cb_t, obj_cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_alloc(mp : *mut rte_mempool) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_calc_mem_size(mp : *const rte_mempool, obj_num : u32, pg_shift : u32, min_chunk_size : *mut u64, align : *mut u64) -> i64);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_dequeue_bulk(mp : *mut rte_mempool, obj_table : *mut *mut core::ffi::c_void, n : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_dequeue_contig_blocks(mp : *mut rte_mempool, first_obj_table : *mut *mut core::ffi::c_void, n : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_enqueue_bulk(mp : *mut rte_mempool, obj_table : *const *const core::ffi::c_void, n : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_free(mp : *mut rte_mempool));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_get_count(mp : *const rte_mempool) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_get_info(mp : *const rte_mempool, info : *mut rte_mempool_info) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_ops_populate(mp : *mut rte_mempool, max_objs : u32, vaddr : *mut core::ffi::c_void, iova : u64, len : u64, obj_cb : *mut rte_mempool_populate_obj_cb_t, obj_cb_arg : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_populate_anon(mp : *mut rte_mempool) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_populate_default(mp : *mut rte_mempool) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_populate_iova(mp : *mut rte_mempool, vaddr : *mut i8, iova : u64, len : u64, free_cb : *mut rte_mempool_memchunk_free_cb_t, opaque : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_populate_virt(mp : *mut rte_mempool, addr : *mut i8, len : u64, pg_sz : u64, free_cb : *mut rte_mempool_memchunk_free_cb_t, opaque : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_put(mp : *mut rte_mempool, obj : *mut core::ffi::c_void));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_put_bulk(mp : *mut rte_mempool, obj_table : *const *const core::ffi::c_void, n : u32));
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_register_ops(ops : *const rte_mempool_ops) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_set_ops_byname(mp : *mut rte_mempool, name : *const i8, pool_config : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_virt2iova(elt : *const core::ffi::c_void) -> u64);
windows_link::link!("dpdk_dummy" "C" fn rte_mempool_walk(func : *mut isize, arg : *mut core::ffi::c_void));
#[cfg(all(feature = "ethdev", feature = "lcore"))]
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_dump(f : *mut super::ethdev:: _IO_FILE));
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_free(mz : *const rte_memzone) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_lookup(name : *const i8) -> *mut rte_memzone);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_max_get() -> u64);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_max_set(max : u64) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_reserve(name : *const i8, len : u64, socket_id : i32, flags : u32) -> *mut rte_memzone);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_reserve_aligned(name : *const i8, len : u64, socket_id : i32, flags : u32, align : u32) -> *mut rte_memzone);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_reserve_bounded(name : *const i8, len : u64, socket_id : i32, flags : u32, align : u32, bound : u32) -> *mut rte_memzone);
windows_link::link!("dpdk_dummy" "C" fn rte_memzone_walk(func : *mut isize, arg : *mut core::ffi::c_void));
windows_link::link!("dpdk_dummy" "C" fn rte_ring_count(r : *const rte_ring) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_create(name : *const i8, count : u32, socket_id : i32, flags : u32) -> *mut rte_ring);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_dequeue(r : *mut rte_ring, obj_p : *mut *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_dequeue_bulk(r : *mut rte_ring, obj_table : *mut *mut core::ffi::c_void, n : u32, available : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_dequeue_burst(r : *mut rte_ring, obj_table : *mut *mut core::ffi::c_void, n : u32, available : *mut u32) -> u32);
#[cfg(all(feature = "ethdev", feature = "lcore"))]
windows_link::link!("dpdk_dummy" "C" fn rte_ring_dump(f : *mut super::ethdev:: _IO_FILE, r : *const rte_ring));
windows_link::link!("dpdk_dummy" "C" fn rte_ring_empty(r : *const rte_ring) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_enqueue(r : *mut rte_ring, obj : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_enqueue_bulk(r : *mut rte_ring, obj_table : *const *const core::ffi::c_void, n : u32, free_space : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_enqueue_burst(r : *mut rte_ring, obj_table : *const *const core::ffi::c_void, n : u32, free_space : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_free(r : *mut rte_ring));
windows_link::link!("dpdk_dummy" "C" fn rte_ring_free_count(r : *const rte_ring) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_full(r : *const rte_ring) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_get_capacity(r : *const rte_ring) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_get_cons_sync_type(r : *const rte_ring) -> rte_ring_sync_type);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_get_memsize(count : u32) -> i64);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_get_prod_sync_type(r : *const rte_ring) -> rte_ring_sync_type);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_get_size(r : *const rte_ring) -> u32);
#[cfg(all(feature = "ethdev", feature = "lcore"))]
windows_link::link!("dpdk_dummy" "C" fn rte_ring_headtail_dump(f : *mut super::ethdev:: _IO_FILE, prefix : *const i8, r : *const rte_ring_headtail));
windows_link::link!("dpdk_dummy" "C" fn rte_ring_init(r : *mut rte_ring, name : *const i8, count : u32, flags : u32) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_is_cons_single(r : *const rte_ring) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_is_prod_single(r : *const rte_ring) -> i32);
#[cfg(all(feature = "ethdev", feature = "lcore"))]
windows_link::link!("dpdk_dummy" "C" fn rte_ring_list_dump(f : *mut super::ethdev:: _IO_FILE));
windows_link::link!("dpdk_dummy" "C" fn rte_ring_lookup(name : *const i8) -> *mut rte_ring);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_mc_dequeue(r : *mut rte_ring, obj_p : *mut *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_mc_dequeue_bulk(r : *mut rte_ring, obj_table : *mut *mut core::ffi::c_void, n : u32, available : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_mc_dequeue_burst(r : *mut rte_ring, obj_table : *mut *mut core::ffi::c_void, n : u32, available : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_mp_enqueue(r : *mut rte_ring, obj : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_mp_enqueue_bulk(r : *mut rte_ring, obj_table : *const *const core::ffi::c_void, n : u32, free_space : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_mp_enqueue_burst(r : *mut rte_ring, obj_table : *const *const core::ffi::c_void, n : u32, free_space : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_reset(r : *mut rte_ring));
windows_link::link!("dpdk_dummy" "C" fn rte_ring_sc_dequeue(r : *mut rte_ring, obj_p : *mut *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_sc_dequeue_bulk(r : *mut rte_ring, obj_table : *mut *mut core::ffi::c_void, n : u32, available : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_sc_dequeue_burst(r : *mut rte_ring, obj_table : *mut *mut core::ffi::c_void, n : u32, available : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_sp_enqueue(r : *mut rte_ring, obj : *mut core::ffi::c_void) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_sp_enqueue_bulk(r : *mut rte_ring, obj_table : *const *const core::ffi::c_void, n : u32, free_space : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_ring_sp_enqueue_burst(r : *mut rte_ring, obj_table : *const *const core::ffi::c_void, n : u32, free_space : *mut u32) -> u32);
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_init(sl : *mut rte_spinlock_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_is_locked(sl : *mut rte_spinlock_t) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_lock(sl : *mut rte_spinlock_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_lock_tm(sl : *mut rte_spinlock_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_init(slr : *mut rte_spinlock_recursive_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_lock(slr : *mut rte_spinlock_recursive_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_lock_tm(slr : *mut rte_spinlock_recursive_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_trylock(slr : *mut rte_spinlock_recursive_t) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_trylock_tm(slr : *mut rte_spinlock_recursive_t) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_unlock(slr : *mut rte_spinlock_recursive_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_recursive_unlock_tm(slr : *mut rte_spinlock_recursive_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_trylock(sl : *mut rte_spinlock_t) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_trylock_tm(sl : *mut rte_spinlock_t) -> i32);
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_unlock(sl : *mut rte_spinlock_t));
windows_link::link!("dpdk_dummy" "C" fn rte_spinlock_unlock_tm(sl : *mut rte_spinlock_t));
windows_link::link!("dpdk_dummy" "C" fn rte_tm_supported() -> i32);
pub const RING_F_EXACT_SZ: i32 = 4i32;
pub const RING_F_MC_HTS_DEQ: i32 = 64i32;
pub const RING_F_MC_RTS_DEQ: i32 = 16i32;
pub const RING_F_MP_HTS_ENQ: i32 = 32i32;
pub const RING_F_MP_RTS_ENQ: i32 = 8i32;
pub const RING_F_SC_DEQ: i32 = 2i32;
pub const RING_F_SP_ENQ: i32 = 1i32;
pub const RTE_MEMPOOL_EVENT_DESTROY: u32 = 1u32;
pub const RTE_MEMPOOL_EVENT_READY: u32 = 0u32;
pub const RTE_MEMPOOL_F_NON_IO: i32 = 64i32;
pub const RTE_MEMPOOL_F_NO_CACHE_ALIGN: i32 = 2i32;
pub const RTE_MEMPOOL_F_NO_IOVA_CONTIG: i32 = 32i32;
pub const RTE_MEMPOOL_F_NO_SPREAD: i32 = 1i32;
pub const RTE_MEMPOOL_F_POOL_CREATED: i32 = 16i32;
pub const RTE_MEMPOOL_F_SC_GET: i32 = 8i32;
pub const RTE_MEMPOOL_F_SP_PUT: i32 = 4i32;
pub const RTE_MEMPOOL_HEADER_COOKIE1: u64 = 13464546529001680469u64;
pub const RTE_MEMPOOL_HEADER_COOKIE2: u64 = 17505195909323763285u64;
pub const RTE_MEMPOOL_MAX_OPS_IDX: i32 = 16i32;
pub const RTE_MEMPOOL_OPS_NAMESIZE: i32 = 32i32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: i32 = 1i32;
pub const RTE_MEMPOOL_TRAILER_COOKIE: u64 = 12525325695590259629u64;
pub const RTE_MEMZONE_16GB: i32 = 512i32;
pub const RTE_MEMZONE_16MB: i32 = 256i32;
pub const RTE_MEMZONE_1GB: i32 = 2i32;
pub const RTE_MEMZONE_256KB: i32 = 65536i32;
pub const RTE_MEMZONE_256MB: i32 = 131072i32;
pub const RTE_MEMZONE_2MB: i32 = 1i32;
pub const RTE_MEMZONE_4GB: i32 = 524288i32;
pub const RTE_MEMZONE_512MB: i32 = 262144i32;
pub const RTE_MEMZONE_IOVA_CONTIG: i32 = 1048576i32;
pub const RTE_MEMZONE_NAMESIZE: i32 = 32i32;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: i32 = 4i32;
pub const RTE_RING_QUEUE_FIXED: u32 = 0u32;
pub const RTE_RING_QUEUE_VARIABLE: u32 = 1u32;
pub const RTE_RING_SYNC_MT: u32 = 0u32;
pub const RTE_RING_SYNC_MT_HTS: u32 = 3u32;
pub const RTE_RING_SYNC_MT_RTS: u32 = 2u32;
pub const RTE_RING_SYNC_ST: u32 = 1u32;
pub const _IO_EOF_SEEN: i32 = 16i32;
pub const _IO_ERR_SEEN: i32 = 32i32;
#[repr(C, packed(8))]
#[cfg(all(feature = "ethdev", feature = "lcore"))]
#[derive(Clone, Copy)]
pub struct _IO_FILE {
    pub _flags: i32,
    pub _IO_read_ptr: *mut i8,
    pub _IO_read_end: *mut i8,
    pub _IO_read_base: *mut i8,
    pub _IO_write_base: *mut i8,
    pub _IO_write_ptr: *mut i8,
    pub _IO_write_end: *mut i8,
    pub _IO_buf_base: *mut i8,
    pub _IO_buf_end: *mut i8,
    pub _IO_save_base: *mut i8,
    pub _IO_backup_base: *mut i8,
    pub _IO_save_end: *mut i8,
    pub _markers: *mut core::ffi::c_void,
    pub _chain: *mut super::ethdev::_IO_FILE,
    pub _fileno: i32,
    pub _flags2: i32,
    pub _old_offset: i64,
    pub _cur_column: u16,
    pub _vtable_offset: i8,
    pub _shortbuf: [i8; 1],
    pub _lock: *mut super::lcore::_IO_lock_t,
    pub _offset: i64,
    pub _codecvt: *mut core::ffi::c_void,
    pub _wide_data: *mut core::ffi::c_void,
    pub _freeres_list: *mut super::ethdev::_IO_FILE,
    pub _freeres_buf: *mut core::ffi::c_void,
    pub __pad5: u64,
    pub _mode: i32,
    pub _unused2: [i8; 20],
}
#[cfg(all(feature = "ethdev", feature = "lcore"))]
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub const _IO_USER_LOCK: i32 = 32768i32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union __rte_ring_hts_pos {
    pub raw: u64,
    pub pos: __rte_ring_hts_pos_pos,
}
impl Default for __rte_ring_hts_pos {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct __rte_ring_hts_pos_pos {
    pub head: u32,
    pub tail: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union __rte_ring_rts_poscnt {
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt_val,
}
impl Default for __rte_ring_rts_poscnt {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct __rte_ring_rts_poscnt_val {
    pub cnt: u32,
    pub pos: u32,
}
pub const __struct_FILE_defined: i32 = 1i32;
#[repr(C, packed(64))]
#[derive(Clone, Copy)]
pub struct rte_mempool {
    pub name: [i8; 26],
    pub pool_config: *mut core::ffi::c_void,
    pub mz: *mut rte_memzone,
    pub flags: u32,
    pub socket_id: i32,
    pub size: u32,
    pub cache_size: u32,
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub private_data_size: u32,
    pub ops_index: i32,
    pub local_cache: *mut rte_mempool_cache,
    pub populated_size: u32,
    pub elt_list: rte_mempool_objhdr_list,
    pub nb_mem_chunks: u32,
    pub mem_list: rte_mempool_memhdr_list,
}
impl Default for rte_mempool {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_mempool_alloc_t = Option<unsafe extern "system" fn(param0: *const rte_mempool) -> i32>;
#[repr(C, packed(64))]
#[derive(Clone, Copy)]
pub struct rte_mempool_cache {
    pub size: u32,
    pub flushthresh: u32,
    pub len: u32,
    pub objs: [*mut core::ffi::c_void; 1024],
}
impl Default for rte_mempool_cache {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_mempool_calc_mem_size_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: u32,
        param2: u32,
        param3: *const u64,
        param4: *const u64,
    ) -> i64,
>;
pub type rte_mempool_ctor_t =
    Option<unsafe extern "system" fn(param0: *const rte_mempool, param1: *const core::ffi::c_void)>;
pub type rte_mempool_dequeue_contig_blocks_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: *const *const core::ffi::c_void,
        param2: u32,
    ) -> i32,
>;
pub type rte_mempool_dequeue_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: *const *const core::ffi::c_void,
        param2: u32,
    ) -> i32,
>;
pub type rte_mempool_enqueue_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: *const *const core::ffi::c_void,
        param2: u32,
    ) -> i32,
>;
pub type rte_mempool_event = u32;
pub type rte_mempool_event_callback = Option<
    unsafe extern "system" fn(
        param0: rte_mempool_event,
        param1: *const rte_mempool,
        param2: *const core::ffi::c_void,
    ),
>;
pub type rte_mempool_free_t = Option<unsafe extern "system" fn(param0: *const rte_mempool)>;
pub type rte_mempool_get_count =
    Option<unsafe extern "system" fn(param0: *const rte_mempool) -> u32>;
pub type rte_mempool_get_info_t = Option<
    unsafe extern "system" fn(param0: *const rte_mempool, param1: *const rte_mempool_info) -> i32,
>;
#[repr(C, packed(64))]
#[derive(Clone, Copy, Default)]
pub struct rte_mempool_info {
    pub contig_block_size: u32,
}
pub type rte_mempool_mem_cb_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: *const core::ffi::c_void,
        param2: *const rte_mempool_memhdr,
        param3: u32,
    ),
>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_mem_range_info {
    pub start: *mut core::ffi::c_void,
    pub length: u64,
    pub is_contiguous: bool,
}
impl Default for rte_mempool_mem_range_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_mempool_memchunk_free_cb_t = Option<
    unsafe extern "system" fn(param0: *const rte_mempool_memhdr, param1: *const core::ffi::c_void),
>;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_memhdr {
    pub next: rte_mempool_memhdr_next,
    pub mp: *mut rte_mempool,
    pub addr: *mut core::ffi::c_void,
    pub iova: u64,
    pub len: u64,
    pub free_cb: *mut rte_mempool_memchunk_free_cb_t,
    pub opaque: *mut core::ffi::c_void,
}
impl Default for rte_mempool_memhdr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
impl Default for rte_mempool_memhdr_list {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_memhdr_next {
    pub stqe_next: *mut rte_mempool_memhdr,
}
impl Default for rte_mempool_memhdr_next {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_mempool_obj_cb_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: *const core::ffi::c_void,
        param2: *const core::ffi::c_void,
        param3: u32,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_objhdr {
    pub next: rte_mempool_objhdr_next,
    pub mp: *mut rte_mempool,
    pub iova: u64,
}
impl Default for rte_mempool_objhdr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
impl Default for rte_mempool_objhdr_list {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_mempool_objhdr_next {
    pub stqe_next: *mut rte_mempool_objhdr,
}
impl Default for rte_mempool_objhdr_next {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_mempool_objsz {
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub total_size: u32,
}
#[repr(C, packed(64))]
#[derive(Clone, Copy)]
pub struct rte_mempool_ops {
    pub name: [i8; 32],
    pub alloc: rte_mempool_alloc_t,
    pub free: rte_mempool_free_t,
    pub enqueue: rte_mempool_enqueue_t,
    pub dequeue: rte_mempool_dequeue_t,
    pub get_count: rte_mempool_get_count,
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    pub populate: rte_mempool_populate_t,
    pub get_info: rte_mempool_get_info_t,
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
impl Default for rte_mempool_ops {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(64))]
#[derive(Clone, Copy)]
pub struct rte_mempool_ops_table {
    pub sl: rte_spinlock_t,
    pub num_ops: u32,
    pub ops: [rte_mempool_ops; 16],
}
impl Default for rte_mempool_ops_table {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_mempool_populate_obj_cb_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: *const core::ffi::c_void,
        param2: *const core::ffi::c_void,
        param3: u64,
    ),
>;
pub type rte_mempool_populate_t = Option<
    unsafe extern "system" fn(
        param0: *const rte_mempool,
        param1: u32,
        param2: *const core::ffi::c_void,
        param3: u64,
        param4: u64,
        param5: *const rte_mempool_populate_obj_cb_t,
        param6: *const core::ffi::c_void,
    ) -> i32,
>;
#[repr(C, packed(1))]
#[derive(Clone, Copy)]
pub struct rte_memzone {
    pub name: [i8; 32],
    pub iova: u64,
    pub len: u64,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub flags: u32,
}
impl Default for rte_memzone {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(64))]
#[derive(Clone, Copy)]
pub struct rte_ring {
    pub name: [i8; 29],
    pub flags: i32,
    pub memzone: *mut rte_memzone,
    pub size: u32,
    pub mask: u32,
    pub capacity: u32,
    pub cache_guard_0: [i8; 64],
    pub cache_guard_1: [i8; 64],
    pub cache_guard_2: [i8; 64],
}
impl Default for rte_ring {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_ring_headtail {
    pub head: u32,
    pub tail: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    pub sync_type: rte_ring_sync_type,
}
impl Default for rte_ring_hts_headtail {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_ring_queue_behavior = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    pub sync_type: rte_ring_sync_type,
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
impl Default for rte_ring_rts_headtail {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type rte_ring_sync_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_spinlock_recursive_t {
    pub sl: rte_spinlock_t,
    pub user: i32,
    pub count: i32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct rte_spinlock_t {
    pub locked: i32,
}
